
class CGConv(nn.Module):
    ''' Mutual Affine Convolution (MAConv) layer '''
    def __init__(self, in_channels, out_channels, kernel_size=1, stride=1, padding=0, bias=True):
        super(CGConv, self).__init__()
        self.split=out_channels
        setattr(self, 'fc{}', nn.Sequential(*[
            nn.Conv2d(in_channels=1, out_channels=out_channels, 
                        kernel_size=kernel_size, stride=stride, padding=padding, bias=bias),
            nn.ReLU(inplace=True),
            nn.Conv2d(in_channels=out_channels, out_channels=out_channels*2, 
                        kernel_size=kernel_size, stride=stride, padding=padding, bias=bias),
        ]))
        setattr(self, 'conv{}', nn.Conv2d(in_channels=in_channels, out_channels=out_channels, 
                                                    kernel_size=3, stride=1, padding=1, bias=bias))
    def forward(self,input,g_input):
        scale, translation = torch.split(getattr(self, 'fc{}')(g_input), (self.split,self.split), dim=1)
        #print("scale:",scale.shape)
        #print("translation:",translation.shape)
        output=getattr(self, 'conv{}')(F.relu(input*torch.sigmoid(scale) + translation))
        return output


class Bandmodulation(nn.Module):
    def __init__(self,in_channels, out_channels, kernel_size=3, stride=1, padding=1, bias=True,split=4):
        super(Bandmodulation,self).__init__()
        self.num_split=split
        self.split_list=[]
        in_split=in_channels//split
        out_split=out_channels//split
        for i in range(self.num_split):
            setattr(self, 'conv{}'.format(i), nn.Conv2d(in_channels=in_split+1, out_channels=in_split, 
                                                        kernel_size=kernel_size, stride=stride, padding=padding, bias=bias))
            setattr(self, 'cgconv{}'.format(i),CGConv(in_channels=in_split,out_channels=out_split))
            self.split_list.append(in_split)
    def forward(self, input,g_input):
        input = torch.split(input, self.split_list, dim=1) #tuple (4,[1,1,128,128])
        output = [] 
        for i in range(self.num_split):
            split_fusion=getattr(self,'conv{}'.format(i))(torch.cat((input[i],g_input),1))
            #print(split_fusion.shape)
            output.append(getattr(self,'cgconv{}'.format(i))(split_fusion,g_input))
        return torch.cat(output, 1)
            
